/**
* Name: Autonomous electric taxi fleet management 
* Author: Ivan Valbuena Galvez
* Description: Model to show how to manage an autonomous electric taxi fleet. It represents a map generated by 2 shapefiles (one for nodes and one for intersections) and includes
* all the required functionalities to simulate a real scenario, with traffic, traffic lights and every possible road of the city of Aranjuez available. The purpose of this model
* is to create a simulation that can be used as a basis for real projects where autonomous fleet management is needed
* Tags: gis, shapefile, graph, agent_movement, skill, autonomous taxi fleet, electric cars
*/
model RoadTrafficComplex

global {
	
	//EN: allows to change between 2D and 3D modes. Code and documentation are tought for 2D mode so its use is recommended
	//ES: permite cambiar entre modo 2D y 3D. El código y la memoria están pensados para el modo 2D por lo que se recomienda mantener este valor a false
	bool  display3D<- false;
	
	//EN: select the shapefiles to use and initialize some variables
	//ES: elige los shapefiles a usar e inicializa algunas variables
	file shape_file_roads <-  file("../includes/RoadsAranjuez.shp");
	file shape_file_nodes <- file("../includes/NodesAranjuez.shp");
	geometry shape <- envelope(shape_file_roads) + 50.0;
	graph road_network;
	int nb_people;
	int nb_taxis;
	map general_speed_map;
	
	//EN: cost discount to the client insertion if the taxi's list is empty, in order to avoid having taxis that are not giving a service
	//ES: coste descontado en la inserción de clientes si la lista del taxi está vacía, con el fin de evitar que haya taxis sin prestar servicios
	float coste_tiempo <- 350.0;
	
	//EN: list used to save costs data for further research
	//ES: lista que almacena datos de los costes para su estudio
	list<float> costes_aux;

	init {
		
		//EN: create the intersections and check if there are traffic lights and chargers or not by looking the values inside the type columns of the shapefile
		//ES: crea las intersecciones y verifica si existen o no semaforos y estaciones de carga mirando en los valores de las columnas del shapefile
		create intersection from: shape_file_nodes with: [is_traffic_signal::(read("type") = "traffic_signals"), is_traffic_signal2::(read("type") = "traffic_signals2"), is_charger::(read("type") = "charger")];

		//EN: create road agents using the shapefile and using the type columns to check their values. It also defines their geometry on the graph
		//ES: crea  los agentes de tipo carretera usando el shapefile correspondiente y asigna los valores acorde a sus columnas. TAmbien define la geometria en el grafo
		create road from: shape_file_roads with: [lanes::int(read("lanes")), oneway::string(read("oneway")), maxspeed::float(read("maxspeed"))] {
			write(maxspeed);
			geom_display <- shape + (2.5 * lanes);
			maxspeed <- self.maxspeed #km / #h;
			switch oneway {
				match "no" {
					create road {
						lanes <- max([1, int(myself.lanes / 2.0)]);
						shape <- polyline(reverse(myself.shape.points));
						maxspeed <- myself.maxspeed;
						geom_display <- myself.geom_display;
						linked_road <- myself;
						myself.linked_road <- self;
					}

					lanes <- int(lanes / 2.0 + 0.5);
				}

				match "-1" {
					shape <- polyline(reverse(shape.points));
				}

			}

		}
		
		//EN: represents the relation between each road's lenght and maxspeed
		//ES: representa la relacion entre la longitud de cada carretera y su velocidad maxima 
		general_speed_map <- road as_map (each::(each.shape.perimeter / each.maxspeed));

		//EN: creation of the road network using the road and intersection agents
		//ES: creacion dl grafo usando los agentes de tipo carretera e interseccion
		road_network <- (as_driving_graph(road, intersection)) with_weights general_speed_map;

		//EN: initialize the traffic light
		//ES: inicializa los semaforos
		ask intersection {
			do initialize;
		}

		//EN: defines people species and its attributes
		//ES: define la especie people y sus atributos
		create people number: nb_people {
			max_speed <- 160 #km / #h;
			vehicle_length <- 5.0 #m;
			right_side_driving <- true;
			proba_lane_change_up <- 0.1 + (rnd(500) / 500);
			proba_lane_change_down <- 0.5 + (rnd(500) / 500);
			location <- one_of(intersection where empty(each.stop)).location;
			security_distance_coeff <- 5 / 9 * 3.6 * (1.5 - rnd(1000) / 1000);
			proba_respect_priorities <- 1.0 - rnd(200 / 1000);
			proba_respect_stops <- [1.0];
			proba_block_node <- 0.0;
			proba_use_linked_road <- 0.0;
			max_acceleration <- 5 / 3.6;
			speed_coeff <- 1.2 - (rnd(400) / 1000);
			threshold_stucked <- int((1 + rnd(5)) #mn);

		}
		
		//EN: defines taxis species and its attributes
		//ES: define la especie taxis y sus atributos
		create taxis number: nb_taxis {
			max_speed <- 160 #km / #h;
			vehicle_length <- 5.0 #m;
			right_side_driving <- true;
			proba_lane_change_up <- 0.1 + (rnd(500) / 500);
			proba_lane_change_down <- 0.5 + (rnd(500) / 500);
			location <- one_of(intersection where empty(each.stop)).location;
			security_distance_coeff <- 5 / 9 * 3.6 * (1.5 - rnd(1000) / 1000);
			proba_respect_priorities <- 1.0 - rnd(200 / 1000);
			proba_respect_stops <- [1.0];
			proba_block_node <- 0.0;
			proba_use_linked_road <- 0.0;
			max_acceleration <- 5 / 3.6;
			speed_coeff <- 1.2 - (rnd(400) / 1000);
			threshold_stucked <- int((1 + rnd(5)) #mn);
			
		}
		
		//EN: defines aux_vehicle species and its attributes
		//ES: define la especie aux_vehicle y sus atributos
		create aux_vehicle number: 1{
			max_speed <- 160 #km / #h;
			vehicle_length <- 5.0 #m;
			right_side_driving <- true;
			proba_lane_change_up <- 0.1 + (rnd(500) / 500);
			proba_lane_change_down <- 0.5 + (rnd(500) / 500);
			location <- one_of(intersection where empty(each.stop)).location;
			security_distance_coeff <- 5 / 9 * 3.6 * (1.5 - rnd(1000) / 1000);
			proba_respect_priorities <- 1.0 - rnd(200 / 1000);
			proba_respect_stops <- [1.0];
			proba_block_node <- 0.0;
			proba_use_linked_road <- 0.0;
			max_acceleration <- 5 / 3.6;
			speed_coeff <- 1.2 - (rnd(400) / 1000);
			threshold_stucked <- int((1 + rnd(5)) #mn);
		}
				

	}
	
	int id_cliente <- 0;
	int num_clientes <- 0;
	int num_rejected <- 0;
	int num_accepted <- 0;
	
	
	//##################################################################
	//EN: variable that defines the probability of creating a new client each cycle, change as needed (a high probability is not recommended if there is no maximum cap for lag issues)
	//ES: variable que define la probabilidad de crear un nuevo cliente cada ciclo, cambiar segun se necesite (no se recomienda una probabilidad alta si no hay un limite de clientes maximos por temas de ralentizaciones)
	float prob_cliente <- 0.01;
	//##################################################################
	
	
	bool nuevo_cliente <- false;
	
	//EN: when conditions are met, this reflex creates a new client in the map (there is a commentated condition which includes a maximum limit of simultaneous clients, use when needed)
	//ES: cuando se cumplen las condiciones, este reflex crea un nuevo cliente en el mapa (hay una condicion comentada que incluye un limite maximo de clientes simultaneos, usar cuando se necesite)
	reflex create_client when: flip(prob_cliente) /*and num_clientes < 10*/ and cycle > 0{
		
		//EN: mechanism that avoids creating a new client just after delivering the last one since this resulted in problems with the tool
		//ES: mecanismo que evita crear un nuevo cliente nada mas dejar al anterior para evitar problemas de comportamiento en la herramienta
		if(nuevo_cliente = true){
			nuevo_cliente <- false; 
		}
		else{
			create clientes number:1;
			num_clientes <- num_clientes + 1;
		
		}
	}
	
	//EN: lists used to store valuable information for later studies
	//ES: listas que almacenan informacion de utilidad para futuros estudios
	list<int> clients_per_taxi; 
	list<int> cycles_no_battery;
	 
	//EN: reflex used to pause the simulation when needed and print required data (change as needed)
	//ES: reflex usado para pausar la simulacion cuando sea necesario y para imprimir informacion requerida (cambiar si se necesita)
	reflex pause when: cycle = 10000{
		
		float coste_imprimir;
		loop i from:0 to: length(costes_aux)-1{
			coste_imprimir <- coste_imprimir + costes_aux[i];
		}
		coste_imprimir <- coste_imprimir/length(costes_aux);
		
		loop element over: taxis{
			add item: element.clients_served to: clients_per_taxi;
			add item: element.no_battery to: cycles_no_battery;
		}
		
		write(clients_per_taxi);
		
		save clients_per_taxi to: "clients.txt" type: "text";
	
		write("MINIMAS BATERIAS");
		loop bat over: taxis{
			write(bat.lowest_battery);
		}
		
		write("BATERIAS ACTUALES");
		loop bat over: taxis{
			write(bat.battery);
		}
	
	
		do pause;
		write("Los costes son " + costes_aux);
		write("hay un total de " + length(costes_aux));
		write("El coste medio ha sido de " + coste_imprimir);
		write("Pausado por el reflex pause, modificar este reflex para pausar en otro momento o nunca hacerlo");
	} 
	
	//EN: variables used to fix some problems when generating new clients (THE PROBLEM SEEMS TO BE SOLVED BUT IT NEEDS MORE TESTS BEFORE ELIMINATING THIS PART)
	//ES: variables utilizadas para arreglar algunos problemas al generar clientes (EL PROBLEMA PARECE RESUELTO PERO ES NECESARIO REALIZAR MAS PRUEBAS ANTES DE ELIMINAR ESTA PARTE)
	intersection destino_global;
	int indice_global;
	path camino_global;
	
	bool pausar <- false;
	int cont_pausa <- 0;
	
	//EN: used to pause the simulation for debugging and code development (change as needed)
	//ES: usada para pausar la simulacion al desarrollar o comprobar el codigo (cambiar si se necesita)
	reflex pause2 when: pausar = true{
		
		if(cont_pausa = 10){
			camino_global <- taxis(indice_global).compute_path(graph: road_network, target: destino_global);
			write("TAXI " + indice_global + " REDIRECCIONADO");
		}
		if(cont_pausa < 10000){
			cont_pausa <- cont_pausa + 1;
			write("EL CONTADOR VALE " + cont_pausa);
			write(taxis(0).current_path);
		}
		else{
		do pause;
		
		}
	}
	
	//EN: reflex used to save every charger position
	//ES: reflex usado para almacenar la posicion de cada estacion de carga
	list pos_chargers;
	reflex chargers when: cycle = 0{
		
		loop inter over:intersection{
			if(inter.is_charger = true){
				add item: inter to: pos_chargers;
				write("CARGADOR: " + inter);
			}
		}
		
	}
	
	//EN: global variables for energy spend
	//ES: variables globales para el gasto energetico
	float mass <- 1200.0;
	float air_density <- 1.24;
	float air_resistance <- 0.37;
	float projected_area <- 2.14 ;
	float gravity <- 9.8;
	float rolling_resistance <- 0.015;
	
	//EN: used to print desired information at the beginning of the execution (change as needed)
	//ES: usada para imprimir la informacion deseada al principio de la ejecucion (cambiar si se necesita)
	reflex print when: cycle = 0{
		
		write("PARAMETROS INICIALES");
		write(mass);
		write(air_density);
		write(air_resistance);
		write(projected_area);
		write(gravity);
		write(rolling_resistance);

	}
	
	//EN: lists used to define charts axis values and store the data that will be displayed in the charts
	//ES: listas usadas para definir los valores de los ejes de los graficos y para almacenar la informacion que se representara en ellos
	list<string> chart_names;
	list<rgb> chart_color;
	list<string> chart_client_names;
	list<float> time_wait;
	
	//EN: reflex to initialize chart lists with their possible values
	//ES: reflex para inicializar las listas de los graficos con sus valores posibles
	reflex create_list when: cycle = 0{
		loop element from:0 to:length(taxis) -1{
			add item: "taxi " + element to:chart_names;
			add item: rnd_color(255) to:chart_color;
		}
	}

	
	
}



//##################################################################################################
//EN: species that will represent the intersection node using the skill_road_node skill
//ES: especie que representa los nodos del grafo (intersecciones) y que usa la skill skill_road_node
species intersection skills: [skill_road_node] {
	
	bool is_traffic_signal;
	bool is_traffic_signal2;
	bool is_charger;
	list<list> stop;
	int time_to_change <- 100;
	int counter <- time_to_change;
	list<road> ways1;
	list<road> ways2;
	bool is_green;
	bool is_origin <- false;
	bool is_destiny <- false;
	rgb color_fire;

	//EN: initializes traffic lights. It also regulates intersections with traffic lights in each direction by giving different state to each direction
	//ES: inicializa los semaforos. Tambien regula las intersecciones con semaforos en cada direccion dando un estado diferente a cada direccion
	action initialize {
		
		if (is_traffic_signal) {
			do compute_crossing;
			stop << [];
			do to_green;

		}
		
		if (is_traffic_signal2) {
			do compute_crossing;
			stop << [];
			do to_red;
		}

	}

	//EN: checks which roads are affected by each traffic light and which are not
	//ES: verifica que carreteras son afectadas por cada semaforo y que carreteras no
	action compute_crossing {
		
		if (length(roads_in) >= 2) {
			road rd0 <- road(roads_in[0]);
			list<point> pts <- rd0.shape.points;
			float ref_angle <- float(last(pts) direction_to rd0.location);
			loop rd over: roads_in {
				list<point> pts2 <- road(rd).shape.points;
				float angle_dest <- float(last(pts2) direction_to rd.location);
				float ang <- abs(angle_dest - ref_angle);
				if (ang > 45 and ang < 135) or (ang > 225 and ang < 315) {
					ways2 << road(rd);
				}

			}

		}

		loop rd over: roads_in {
			if not (rd in ways2) {
				ways1 << road(rd);
			}
	

		}

	}
	
	//EN: change the traffic light to green and allows cars blocked to continue their way
	//ES: cambia el semaforo a verde y permite a los coches bloqueados proseguir su camino
	action to_green {
		
		stop[0] <- ways2;
		color_fire <- #green;
		is_green <- true;
	}

	//EN: change the traffic light to red and blocks that way to incoming cars
	//ES: cambia el semaforo a rojo y bloquea el camino a los coches que vengan
	action to_red {
		
		stop[0] <- ways1;
		color_fire <- #red;
		is_green <- false;
	}

	//EN: this reflex manages a counter for each traffic light in order to change its state when a threshold is reached
	//ES: este reglex administra un contador para cada semaforo con el fin de cambiar su estado cuando se alcance un umbral establecido
	reflex dynamic_node when: is_traffic_signal or is_traffic_signal2  {
		
		counter <- counter + 1;
		if (counter >= time_to_change) {
			counter <- 0;
			if is_green {
				do to_red;
			} else {
				do to_green;
			}

		}

	}
	
	//EN: defines how intersection are displayed on the map depending on its type
	//ES: define como se representan las intersecciones en el mapa segun su tipo
	aspect default {
		
		if (display3D) {
			if (is_traffic_signal or is_traffic_signal2) {
				draw box(1, 1, 10) color: #black;
				draw sphere(3) at: {location.x, location.y, 10} color: color_fire;
			}
		} else {
			
			if (is_traffic_signal or is_traffic_signal2) {
				draw circle(3) color: color_fire;
			}

			if(is_charger){
				draw triangle(20) color: #yellow;
			}
			
			if(self.is_origin = true){
				draw circle(20) color:#blue;
			}
			if(self.is_destiny = true){
				draw circle(20) color:#red;
			}
		}	
	}
	
	
}



//##################################################################################################
//EN: species that will represent the roads and uses the skill skill_road
//ES: especie que representa las carreteras y usa la skill skill_road
species road skills: [skill_road] {
	
	geometry geom_display;
	string oneway;

	//EN: defines how roads are displayed on the map
	//ES: define como se representan las carreteras en el mapa
	aspect default {
		
		if (display3D) {
			draw geom_display color: #lightgray;
		} else {
			draw shape color: #white end_arrow: 1;
		}
		
	}

}



//##################################################################################################
//EN: people species whose agents will move on the graph of roads to a target and using the driving skill
//ES: especie people cuyos agentes se moveran por el grafo de carreteras a un objetivo usando la skill driving
species people skills: [advanced_driving] {
	
	rgb color <- rnd_color(255);
	int counter_stucked <- 0;
	int threshold_stucked;
	bool breakdown <- false;
	intersection target;
	intersection target2;

	//EN: reflex that assigns a random target to agents without one. If the new target coincides with the previous one there is an error where no path is given, so it also checks this to avoid that situation with a loop
	//ES: reflex que asigna un objetivo aleatorio a los agentes que no tengan uno. Si el nuevo objetivo coincide con el anterior ocurre un error donde no existe camino a seguir, por lo que se evita esta situacion con un bucle
	reflex time_to_go when: final_target = nil {
		
		target <- one_of(intersection );
		current_path <- compute_path(graph: road_network, target: target);
		if (current_path = nil) {
			bool encontrado <- false;
			loop while: encontrado = false{
				target2 <- one_of(intersection );
				if(target2 != target){
					encontrado <- true;
				}
				
			}
			target <- target2;
			current_path <- compute_path(graph: road_network, target: target);
			
		}

	}

	//EN: reflex used to move an agent to its current target
	//ES: reflex usado para mover a un agente a su objetivo actual
	reflex move when: current_path != nil and final_target != nil {
		
		do drive;
		if (final_target != nil) {
			if real_speed < 5 #km / #h {
				counter_stucked <- counter_stucked + 1;
				if (counter_stucked mod threshold_stucked = 0) {
					proba_use_linked_road <- min([1.0, proba_use_linked_road + 0.1]);
				}
	
			} else {
				counter_stucked <- 0;
				proba_use_linked_road <- 0.0;
			}
		}
	}

	//EN: defines how agents of this specie are displayed on the map
	//ES: define como se representan los agentes de esta especie en el mapa
	aspect default {
		
		if (display3D) {
			point loc <- calcul_loc();
			draw rectangle(1,vehicle_length) + triangle(1) rotate: heading + 90 depth: 1 color: color at: loc;
			if (breakdown) {
				draw circle(1) at: loc color: #red;
			}
		}else {
			draw breakdown ? square(8) : triangle(8) color: color rotate: heading + 90;
		}
		
	}

	//EN: calculates the location of an agent. Only used in 3D displays (out of our scope)
	//ES: calcula la localizacion de un agente. Solo se usa para representaciones en 3D (fuera del alcance de este proyecto)
	point calcul_loc {
		
		if (current_road = nil) {
			return location;
		} else {
			float val <- (road(current_road).lanes - current_lane) + 0.5;
			val <- on_linked_road ? -val : val;
			if (val = 0) {
				return location;
			} else {
				return (location + {cos(heading + 90) * val, sin(heading + 90) * val});
			}

		}

	} }



//##################################################################################################
//EN: taxis species whose agents are the taxis and is child of people species
//ES: especie taxis cuyos agentes son los taxis y que es hija de la especie people
species taxis parent: people{
	
	//EN: represents the battery of the taxis in Ws. Since this is a simulation the value differs from reality for study purposes, a real car would have approximately a 0 more or, in other words, 200000000.0
	//ES: representa la bateria de los taxis en Ws. Dado que es una simulacion el valor difiere de un caso real con proposito de estudios, un coche real tendria aproximadamente un 0 mas, es decir, 200000000.0
	float battery <- 20000000.0;
	
	float speed1 <- 0.0;
	float speed2 <- 0.0;
	float acceleration <- 0.0;
	bool asignado <- false;
	bool ocupado <- false;
	bool charging <- false;
	bool in_charger <- false;
	list servicio;
	
	int clients_served <- 0;
	int no_battery <- 0;
	float lowest_battery <- 9999999999999999.9;
	
	//EN: each cycle the battery of each taxi is reduced according to the ecuation presented in this reflex. It also checks if any taxi is out of battery
	//ES: cada ciclo la bateria de cada taxi se reduce acorde a la ecuacion presentada en este reflex. Tambien se verifica si algun taxi se ha quedado sin bateria 
	reflex discharge when: in_charger = false{

		do calc_acceleration;

		battery <- battery - (mass * self.real_speed * abs(acceleration) + 0.5 * air_density * air_resistance * projected_area *self.real_speed^3 + rolling_resistance * mass * gravity * real_speed);

		if(battery <= 0){
			write("BATERÍA AGOTADA");
			no_battery <- no_battery + 1;
			max_speed <- 0.0;
		}
		
		if(battery < lowest_battery){
			lowest_battery <- battery;
		}
		
	}
	
	//EN: calculates the acceleration using the speed in this cycle and the last one
	//ES: calcula la aceleracion en base a la velocidad en este ciclo y el anterior
	action calc_acceleration{
		speed1 <- speed2;
		speed2 <- self.real_speed;
		if(speed2 != 0){
			acceleration <- speed2 - speed1;
		}
		else{
			acceleration <- -speed1;
		}
		
	}
	
	//EN: similar to the time_to_go reflex in people specie but adding new conditions so that this does not apply if the taxi is already assigned or it is charging batteries
	//ES: similar al reflex time_to_go de la especie people pero anadiendo nuevas condiciones para que no se aplique en caso de que el taxi ya este asignado o este recargando baterias
	reflex time_to_go when: final_target = nil and asignado = false and charging = false{
		
		target <- one_of(intersection );
		current_path <- compute_path(graph: road_network, target: target);
		if (current_path = nil) {
			bool encontrado <- false;
			loop while: encontrado = false{
				target2 <- one_of(intersection );
				if(target2 != target){
					encontrado <- true;
				}
				
			}
			target <- target2;
			current_path <- compute_path(graph: road_network, target: target);
			
		}
	}
	
	//EN: this reflex makes a taxi go to pick up the first client in its list when conditions are met
	//ES: este reflex hace que un taxi vaya a recoger al primer cliente de su lista si se cumplen las condiciones
	reflex search_client when: num_clientes > 0 and asignado = false and empty(self.servicio) = false and charging = false{
		
		clientes aux <- self.servicio[0];
		target <- aux.origen;
		current_path <- compute_path(graph: road_network, target: target);
		if (current_path = nil){
			do fix_target;
		}
		else{
			asignado <- true;
		}

	}
	
	//EN: reflex used to fix the problem ocurred when the node assigned as target coincides with the taxi position. This reflex assigns a temporary target so that the taxi gets out of the node and immediately then it is marked as the objective
	//ES: reflex usado para solucionar el problema que ocurre cuando el nodo asignado como objetivo coincide con la posicion del taxi. Este reflex asigna un objetivo temporal para que el taxi salga del nodo e, inmediatamente, lo reasigna como objetivo
	action fix_target{
		
		target <- one_of(intersection );
		current_path <- compute_path(graph: road_network, target: target);
		if (current_path = nil) {
			bool encontrado <- false;
			loop while: encontrado = false{
				target2 <- one_of(intersection );
				if(target2 != target){
					encontrado <- true;
				}
				
			}
			target <- target2;
			current_path <- compute_path(graph: road_network, target: target);
			
		}	
	}

	//EN: reflex used to move an agent to its current target
	//ES: reflex usado para mover a un agente a su objetivo actual
	reflex move when: current_path != nil and final_target != nil{
		
		do drive;
		if (final_target != nil) {
			if real_speed < 5 #km / #h {
				counter_stucked <- counter_stucked + 1;
				if (counter_stucked mod threshold_stucked = 0) {
					proba_use_linked_road <- min([1.0, proba_use_linked_road + 0.1]);
				}
	
			} else {
				counter_stucked <- 0;
				proba_use_linked_road <- 0.0;
			}
		}
	}
	
	//EN: reflex used to pick a client when the taxi has arrived to the origin
	//ES: reflex usado para recoger a un cliente cuando el taxi ha llegado al origen
	reflex pick_client when: current_index = length(targets) -1 and asignado = true and distance_to_goal = 0 and ocupado = false{
		
		ocupado <- true;
		clientes aux <- self.servicio[0];
		aux.recogido <- true;
		aux.origen.is_origin <- false;
		target <- aux.destino;
		current_path <- compute_path(graph: road_network, target: target);
		
	}
	
	//EN: reflex used to deliver a client to its destiny when the taxi has reached that location
	//ES: reflex usado para dejar un cliente en su destino cuando el taxi haya llegado a dicha localizacion
	reflex deliver_client when: current_index = length(targets) -1 and ocupado = true and distance_to_goal = 0{
		
		ocupado <- false;
		asignado <- false;
		nuevo_cliente <- true;
		clientes aux <- self.servicio[0];
		aux.destino.is_destiny <- false;
		remove from: self.servicio index: 0;
		num_clientes <- num_clientes -1;
		clients_served <- clients_served + 1;
		ask aux{
			do die;
		}
	} 
	
	//EN: reflex used to send a taxi to the closest charger when its battery has surpass a threshold and some conditions are met
	//ES: reflex usado para mandar un taxi a la estacion de carga cuando sus baterias han sobrepasado un umbral y se cumplen ciertas condiciones
	reflex move_to_charger when: battery < 0.15 * 20000000.0 and empty(self.servicio) = true and charging = false{
		
		float closest <- 999999999999.9;
		float closest_aux <- 0.0;
		path calculo;
		
		//EN: loop used to check which charger is the closest
		//ES: bucle utilizado para comprobar que estacion de carga es la mas cercana
		loop charger over: pos_chargers{
			calculo <- compute_path(graph: road_network, target: charger);
				if(calculo = nil){
	
					write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
				}
				
				else{
				
					if(length(calculo.edges) > 0){
						
						loop j over: calculo.edges{
							closest_aux <- closest_aux + float(general_speed_map [j]);
						}
						
					}
					
					if(closest_aux < closest){
						closest <- closest_aux;
						closest_aux <- 0.0;
						target <- charger;
						
					}
				
				}
		}
		
		charging <- true;
		current_path <- compute_path(graph: road_network, target: target);
	}
	
	//EN: reflex to stop a taxi when it is charging
	//ES: reflex para parar un taxi cuando este recargando baterias 
	reflex stop_taxi when: current_index = length(targets) -1 and charging = true and distance_to_goal = 0{
		
		max_speed <- 0.0;
		in_charger <- true;
	
	}
	
	//EN: reflex to gradually increase a charging taxi's battery until it is fully charged
	//ES: reflex para incrementar gradualmente la bateria de un taxi en carga hasta que alcance el valor maximo
	reflex charge_taxi when: in_charger = true{
		
		if(battery < 20000000.0){
			
			write("CARGANDO BATERIA CON " + battery);
			battery <- battery + 0.002 * 20000000.0;

		}
		
		else{
			max_speed <- 160 #km / #h;
			battery <- 20000000.0;
			charging <- false;
			in_charger <- false;
		}
	}
	
	//EN: reflex used to debug the code by including the desired prints (this is an example, change to add what you need)
	//ES: reflex usado para depurar el codigo incluyendo las impresiones en pantalla deseadas (esto es un ejemplo, cambiar para incluir lo que necesites)
	reflex depuracion{
		
		/*write("" + self + " objetivo " + self.current_road );
		write("" + self + " objetivo " + self.current_index );
		write("" + self + " objetivo " + self.current_target );
		write("" + self + " objetivo " + self.current_path );
		write("" + self + " objetivo " + self.distance_to_goal );*/
		/*write("EL PATH ACTUAL ES " + current_path);
		write(servicio);
		write(charging);
		write(battery);
		write("" + self + " tiene como objetivo " + target);
		write("" + self + " tiene como objetivo " + final_target);
		write("" + self + " tiene como objetivo " + current_target);*/
		/*write("El objetivo de " + self + " es " + target);
		write("El objetivo final de " + self + " es " + final_target);*/
		//write("La lista " + self + " es " + servicio);
		//write("El camino de " + self + " es " + current_path);

		/*write("La longitud es " + road(18).shape.perimeter);
		write("General map" + general_speed_map[road(18)]);
		write("Vel maxima " + road(18).maxspeed);*/
		/* 
		loop z over: road{
			if(z.maxspeed > 14){
			write("La calle " + z + " tiene una velocidad de " + z.maxspeed);
			
			}
		}*/

		
		/*if(self = taxis(0)){
		write("" + self + " tiene como objetivo " + current_target);
		write("" + self + " esta a una distancia de " + distance_to_goal);
		
		}*/
		

	}
	
	//EN: defines how taxis are displayed on the map depending on their state, free or busy
	//ES: define como se representan los taxis en el mapa segun su estado, libre u ocupado
	aspect default {
		
		if (display3D) {
			point loc <- calcul_loc();
			draw rectangle(1,vehicle_length) + triangle(1) rotate: heading + 90 depth: 1 color: rgb('green') at: loc;
			if (breakdown) {
				draw circle(1) at: loc color: #red;
			}
		}else {
			if(ocupado = false){
			
				draw breakdown ? square(8) : square(20) color: color;
			
			}
			
			else{
				draw breakdown ? square(8) : square(20) color: rgb('red');
			}
			
		}
		
	}
	
}



//##################################################################################################
//EN: auxiliary species used later as a mechanism to fix a problem with the tool
//ES: especie auxiliar usada mas adelante como mecanismo para solventar un problema con la herramienta
species aux_vehicle parent: people{
	
}




//##################################################################################################
//EN: clientes species whose agents are the clients to serve
//ES: especie clientes cuyos agentes son los clientes a servir
species clientes{
	
	intersection origen;
	intersection destino;
	bool asignado <- false;
	bool recogido <- false;
	float tiempo_espera <- 0.0;
	int contador_espera <- 0;
	bool energia_insuficiente <- false;
	int id <- -1;
	
	//EN: reflex used to position a client's origin and destiny in the map when it is created always following the restrictions
	//ES: reflex usado para posicionar el origen y destino de un cliente cuando este es creado siempre siguiendo las restricciones impuestas
	reflex position_client when: self.origen = nil or self.destino = nil{
		
		self.origen <- one_of(intersection );
		
		loop while: origen.is_origin = true{
			self.origen <- one_of(intersection );
		}
		
		self.origen.is_origin <- true;
		
		self.destino <- one_of(intersection );
		
		loop while: self.origen = self.destino or self.destino.is_destiny = true{
			self.destino <- one_of(intersection );
		}
		
		self.destino.is_destiny <- true;
		write("NUEVO CLIENTE");
	}
	
	//EN: reflex used to assign a client to the optimal position in a taxi's list. This is the most important reflex for the fleet management
	//ES: reflex usado para asignar un cliente a la posicion optima de la lista de un taxi. Es el reflex mas importante para la gestion de la flota
	reflex assign_client when: origen != nil and destino != nil and asignado = false{

		float coste_inicial <- 0.0;
		float coste_aux <- 0.0;
		float coste_aux_imprimir <- 0.0;
		float coste_anadido <- 9999999999999999.9;
		float coste_total <- 0.0;
		path camino_aux;
		intersection destino_actual;
		list destinos_actuales;
		int indice_taxi <- -1;
		int indice_lista;
		taxis elegido;
		agent aux_source;
		
		
		
		float tiempo_espera_acumulado <- 0.0;
		
		//EN: it has to check the list of every single taxi
		//ES: debe comprobar las listas de cada taxi
		loop i from:0 to: length(taxis)-1{
			
			destino_actual <- taxis(i).target;
			add item: destino_actual to: destinos_actuales;
			
			if(taxis(i).battery > 20000000.0 * 0.15 and taxis(i).in_charger = false){
			
			//EN: if the list is empty it is the first possible case
			//ES: si la lista esta vacia es el primer caso posible
			if(length(taxis(i).servicio) = 0){
				
				aux_source <- taxis(i).current_road;
				road aux_road <- road(aux_source);
				intersection source_intersection <- intersection(aux_road.source_node);	
				
				//EN: if the list is empty, the insertion additional cost can be easily calculated, since it is just the cost of going to the origin from the position of the taxi and then going to the destiny with the client
				//ES: si la lista esta vacia el coste adicional de la insercion es calculado facilmente, ya que es simplemente el coste de ir al origen desde la posicion actual del taxi y despues ir al destino con el cliente

				camino_aux <- aux_vehicle[0].compute_path(graph: road_network, target: origen, source: source_intersection);

				//EN: this test is done after every call to compute_path action in order to verify if any error is happening, like the taxi being already in the node (in this case the distance is 0 and a message is print)
				//ES: este test se hace tras cada llamada a la accion compute_path para verificar si algun error esta ocurriendo, como que el taxi se encuentra ya en el nodo (en ese caso la distancia es 0 y se imprime un mensaje)
				if(camino_aux = nil){
				
					write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
				}
				
				else{
				
				//EN: this if is repeated several times in this reflex, it calculates the total sum of the costs of all roads that form the path
				//ES: este if se repite varias veces en este reflex, calcula la suma total del coste de todas las carreteras que conforman el camino
				if(length(camino_aux.edges) > 0){
					
					loop j over: camino_aux.edges{
						coste_aux <- coste_aux + float(general_speed_map [j]);
					}
						
				}
				
				}
						
				camino_aux <- aux_vehicle[0].compute_path(graph: road_network, target: destino, source: origen);
				
				if(camino_aux = nil){
				
					write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
				}
				
				else{
				
					if(length(camino_aux.edges) > 0){
						
						loop j over: camino_aux.edges{
							coste_aux <- coste_aux + float(general_speed_map [j]);
						}
						
					}
				
				}
						
						//EN: checks wether the new calculated total cost is lower than the global lowest one having applied any discount or addition imposed
						//ES: comprueba si el nuevo coste total calculado es menor que el menor global habiendo aplicado cualquier descuento o anadido impuesto
						if(coste_aux - coste_tiempo < coste_anadido){
							
							//EN: checks if the taxi would have enough battery to serve the inserted client and reach a charger
							//ES: comprueba que el taxi tendria suficiente bateria para servir al cliente insertado y llegar a una estacion de carga
							do calculate_expense(taxis(i), indice_lista + 1);
							if(energia_insuficiente = false){
								
								coste_aux_imprimir <- coste_aux;
								coste_anadido <- coste_aux - coste_tiempo;
								indice_lista <- -1;
								indice_taxi <- i;
							}
							
							energia_insuficiente <- false;
						}
						
						coste_aux <- 0.0;
						coste_inicial <- 0.0;
			}
			
			else{
				
				
			
				//EN: if the list is not empty, it has to check every single position in the list to see where the optimal insertion is (excluding the first position of the list since it is a client that is currently being served)
				//ES: si la lista no esta vacia, debe comprobar cada posicion de la misma para ver cual es el punto optimo de insercion (excluyendo la primera posicion ya que es un cliente que esta recibiendo su servicio actualmente)
				loop inicial from: 0 to: length(taxis(i).servicio)-1{
					
					if(inicial < length(taxis(i).servicio)-1){
						clientes aux <- taxis(i).servicio[inicial];
						clientes aux2 <- taxis(i).servicio[inicial + 1];
						
						
						//############## START OF EXTRA PART ############## 
						
						//EN: this extra part calculates the total cost of the route itself, without the insertion. It is just used for tests and studies
						//ES: esta parte extra calcula el coste de la ruta en si, sin la insercion. Se usa para tests y estudios posteriores
						
						camino_aux <- aux_vehicle[0].compute_path(graph: road_network, target: aux2.origen, source: aux.destino);
						
						if(camino_aux = nil){
				
							write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
						}
				
						else{
						
							if(length(camino_aux.edges) > 0){
								
								loop j over: camino_aux.edges{
									coste_inicial <- coste_inicial + float(general_speed_map [j]);
								}
								coste_total <- coste_total + coste_inicial;
							
							}
							
						}
						
						//############## END OF EXTRA PART ##############
						
						
						/*EN: if the list is not empty, the total cost to calculate is quite different. The reflex must calculate the cost of going from the previous client's destiny to the origin of the inserted one, then add the cost of 
						carrying that client to his/her destiny and finally, if there is another client in the next position of the list, add the cost of going from the inserted client's destiny to the last one's origin*/
						
						/*ES: si la lista no esta vacia, el coste total a calcular es diferente. El reflex debe calcular el coste de ir desde el destino del cliente anterior al insertado hasta el origen del cliente insertado, luego sumar el coste de llevar
						a ese cliente a su destino y, finalmente, si hay un cliente en la siguiente posicion de la lista al insertado, se debe sumar el coste de ir desde el destino del cliente insertado al origen de este ultimo*/
						camino_aux <- aux_vehicle[0].compute_path(graph: road_network, target: origen, source: aux.destino);
						
						if(camino_aux = nil){
				
							write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
						}
						
						else{
						
							if(length(camino_aux.edges) > 0){
								
								loop j over: camino_aux.edges{
									coste_aux <- coste_aux + float(general_speed_map [j]);
								}
								
							}
						
						}
							
						camino_aux <- aux_vehicle[0].compute_path(graph: road_network, target: destino, source: origen);
						
						if(camino_aux = nil){
				
							write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
						}
						
						else{
						
							if(length(camino_aux.edges) > 0){
								
								loop j over: camino_aux.edges{
									coste_aux <- coste_aux + float(general_speed_map [j]);
								}
								
							}
						
						}
							
						camino_aux <- aux_vehicle[0].compute_path(graph: road_network, target: aux2.origen, source: destino);
						
						if(camino_aux = nil){
				
							write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
						}
						
						else{
						
							if(length(camino_aux.edges) > 0){
								
								loop j over: camino_aux.edges{
									coste_aux <- coste_aux + float(general_speed_map [j]);
								}
								
							}
						
						}
							
							
						//EN: this loop is used to add an additional cost to the insertion depending on the amount of time waited by the clients that are already in the list, in order to avoid having clients that are always waiting and never served
						//ES: este bucle se usa para sumar un coste adicional a la insercion dependiendo de la cantidad de tiempo esperada por los clientes que estan ya en la lista, evitando que haya clientes que esten siempre esperando y no sean servidos
						loop adicional from:inicial to:length(taxis(i).servicio)-1{
							clientes espera <- taxis(i).servicio[adicional];
							tiempo_espera_acumulado <- tiempo_espera_acumulado + espera.tiempo_espera;
						}
						
						
						//EN: checks wether the new calculated total cost is lower than the global lowest one having applied any discount or addition imposed
						//ES: comprueba si el nuevo coste total calculado es menor que el menor global habiendo aplicado cualquier descuento o anadido impuesto
						if(coste_aux - coste_inicial + tiempo_espera_acumulado < coste_anadido){
							
							//EN: checks if the taxi would have enough battery to serve the inserted client and reach a charger
							//ES: comprueba que el taxi tendria suficiente bateria para servir al cliente insertado y llegar a una estacion de carga
							do calculate_expense(taxis(i), indice_lista + 1);
							if(energia_insuficiente = false){
								
								coste_aux_imprimir <- coste_aux - coste_inicial + tiempo_espera_acumulado;
								coste_anadido <- coste_aux - coste_inicial + tiempo_espera_acumulado;
								indice_lista <- inicial;
								indice_taxi <- i;

								
							}
							energia_insuficiente <- false;
						}
						
						coste_aux <- 0.0;
						coste_inicial <- 0.0;
						tiempo_espera_acumulado <- 0.0;
						
					}
					
					else{
							
							//EN: this last case is similar to the previous one, but there is no client in the list after the inserted one, so the cost of going from the inserted client's destiny to the following client's origin is not added
							//ES: este ultimo caso es similar al anterior, pero no hay un cliente en la lista despues del insertado, por lo que el coste de ir desde el destino del insertado al origen del siguiente no se suma
							clientes aux <- taxis(i).servicio[inicial];
							
							camino_aux <- aux_vehicle[0].compute_path(graph: road_network, target: origen, source: aux.destino);
							
							
							if(camino_aux = nil){
				
								write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
							}
							
							else{
							
								if(length(camino_aux.edges) > 0){
									
									loop j over: camino_aux.edges{
										coste_aux <- coste_aux + float(general_speed_map [j]);
									}
									
								}
							
							}
								
							camino_aux <- aux_vehicle[0].compute_path(graph: road_network, target: destino, source: origen);
							
							if(camino_aux = nil){
				
								write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
								
							}
				
							else{
							
								if(length(camino_aux.edges) > 0){
									
									loop j over: camino_aux.edges{
										coste_aux <- coste_aux + float(general_speed_map [j]);
									}
									
								}
							
							}
								
							//EN: this loop is used to add an additional cost to the insertion depending on the amount of time waited by the clients that are already in the list, in order to avoid having clients that are always waiting and never served
							//ES: este bucle se usa para sumar un coste adicional a la insercion dependiendo de la cantidad de tiempo esperada por los clientes que estan ya en la lista, evitando que haya clientes que esten siempre esperando y no sean servidos
							loop adicional from:inicial to:length(taxis(i).servicio)-1{
								clientes espera <- taxis(i).servicio[adicional];
								tiempo_espera_acumulado <- tiempo_espera_acumulado + espera.tiempo_espera;
								
							}
							

							//EN: checks wether the new calculated total cost is lower than the global lowest one having applied any discount or addition imposed
							//ES: comprueba si el nuevo coste total calculado es menor que el menor global habiendo aplicado cualquier descuento o anadido impuesto
							if(coste_aux + tiempo_espera_acumulado < coste_anadido){
								
								//EN: checks if the taxi would have enough battery to serve the inserted client and reach a charger
								//ES: comprueba que el taxi tendria suficiente bateria para servir al cliente insertado y llegar a una estacion de carga
								do calculate_expense(taxis(i), indice_lista + 1);
								if(energia_insuficiente = false){
									
									coste_aux_imprimir <- coste_aux;
									coste_anadido <- coste_aux + tiempo_espera_acumulado;
									indice_lista <- inicial;
									indice_taxi <- i;
									
								}
								
								energia_insuficiente <- false;
							}
							
							coste_aux <- 0.0;
							coste_inicial <- 0.0;
							tiempo_espera_acumulado <- 0.0;
						
					
						}
					
				}
				
				coste_total <- 0.0;
			
			}
			
			}
		}
		
		
		add coste_aux_imprimir to: costes_aux;
		
		//EN: if none of the taxis can serve the client without running out of battery the client is rejected
		//ES: si ninguno de los taxis puede servir al cliente sin quedarse sin bateria el cliente es rechazado
		if(indice_taxi = -1){
			
			write("EL CLIENTE " + self + "NO PUEDE SER ABASTECIDO POR NINGUN TAXI");
			self.origen.is_origin <- false;
			self.destino.is_destiny <- false;
			nuevo_cliente <- true;
			num_clientes <- num_clientes -1;
			num_rejected <- num_rejected + 1;
			do die;
			
			
		}
		
		
		//EN: on the other hand, the client is inserted to the selected taxi's list in the optimal position
		//ES: en otro caso el cliente es insertado en la lista del taxi seleccionado en la posicion optima
		else{
			
			id <- id_cliente;
			add item: "cliente " + id to: chart_client_names;
			add item: tiempo_espera to: time_wait;
			id_cliente <- id_cliente + 1;
			num_accepted <- num_accepted + 1;
			add self to: taxis(indice_taxi).servicio at: indice_lista + 1;
			
			
			//EN: loop used to fix some problems when generating new clients, solved by reasigning their previous objective (THE PROBLEM SEEMS TO BE SOLVED BUT IT NEEDS MORE TESTS BEFORE ELIMINATING THIS PART)
			//ES: bucle utilizado para arreglar algunos problemas al generar clientes, resuelto reasignando su objetivo anterior (EL PROBLEMA PARECE RESUELTO PERO ES NECESARIO REALIZAR MAS PRUEBAS ANTES DE ELIMINAR ESTA PARTE)
			loop a from:0 to: length(taxis)-1{
				if(taxis(a).current_path = nil){
						pausar <- true;
						ask taxis(a){
							do fix_target;
						}
						destino_global <- destinos_actuales[a];
						indice_global <- a;
				}
			}

			clientes test <- taxis(indice_taxi).servicio[0];
			asignado <- true;
		}
	}
	
	//EN: checks whether the taxi would have battery to serve all its list and get to the nearest charger or not including the new inserted client. This action is executed before inserting the client, but the client has to be used to do the calculations as if it was already inserted
	//ES: comprueba si el taxi tendra bateria suficiente para servir a toda su lista y llegar a la estacion de carga mas cercana. Esta accion se ejecuta antes de insertar al cliente, pero el cliente debe ser usado para realizar los calculos como si ya hubiera sido insertado
	action calculate_expense (taxis actual, int indice){
		
		float battery_aux <- actual.battery;
		float battery_loss <- 0.0;
		path gasto_aux;
		intersection ultima;
		agent aux_source2;
		
		aux_source2 <- actual.current_road;
		road aux_road2 <- road(aux_source2);
		intersection source_intersection2 <- intersection(aux_road2.source_node);
		
		//EN: in this case the reflex has to check the battery used by the taxi given in order to serve all its list and reach the nearest charger
		//ES: en este caso el reflex debe comprobar la bateria usada por el taxi dado al servir a toda su lista y llegar a la estacion de carga mas cercana
		loop posicion from:0 to:length(actual.servicio)-1{
			
			if(length(actual.servicio)-1 > 0){
			
				//EN: it is important to detect where the client's insertion is supposed to be done, since the behaviour will change
				//ES: es importante detectar donde se supone que se realiza la insercion del cliente, puesto que el comportamiento cambia
				if(posicion = indice){
					
					if(posicion = 0){
						gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: origen, source: source_intersection2);
								
								if(gasto_aux = nil){
					
									write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
									
								}
								
								else{
								
									if(length(gasto_aux.edges) > 0){
										
										loop j over: gasto_aux.edges{
											battery_loss <- battery_loss + float(general_speed_map [j]);
										}
										
									}
								
								}
								
						gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: destino, source:origen);
						ultima <- destino;		
								if(gasto_aux = nil){
					
									write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
									
								}
								
								else{
								
									if(length(gasto_aux.edges) > 0){
										
										loop j over: gasto_aux.edges{
											battery_loss <- battery_loss + float(general_speed_map [j]);
										}
										
									}
								
								}
								
								
								
						
					}
					
					
					//EN: if the list has more elements, it will check the extra batery waste done due to the insertion
					//ES: si la lista tiene mas elementos, comprobara el gasto extra de bateria debido a la insercion
					else{
						clientes aux3 <- actual.servicio[posicion - 1];
						clientes aux4 <- actual.servicio[posicion];
						
						gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: origen, source: aux3.destino);
								
								if(gasto_aux = nil){
					
									write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
									
								}
								
								else{
								
									if(length(gasto_aux.edges) > 0){
										
										loop j over: gasto_aux.edges{
											battery_loss <- battery_loss + float(general_speed_map [j]);
										}
										
									}
								
								}
								
						gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: destino, source: origen);
								
								if(gasto_aux = nil){
					
									write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
									
								}
								
								else{
								
									if(length(gasto_aux.edges) > 0){
										
										loop j over: gasto_aux.edges{
											battery_loss <- battery_loss + float(general_speed_map [j]);
										}
										
									}
								
								}
								
						gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: aux4.origen, source: destino);
						ultima <- aux4.origen;		
								if(gasto_aux = nil){
					
									write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
									
								}
								
								else{
								
									if(length(gasto_aux.edges) > 0){
										
										loop j over: gasto_aux.edges{
											battery_loss <- battery_loss + float(general_speed_map [j]);
										}
										
									}
								
								}
					}
				}
				
				//EN: if it is not in the inserted client's index, the behaviour is different
				//ES: si no esta en el indice del cliente insertado el comportamiento es diferente
				else{
					
					//EN: if it is not in the first position of the list, it will have at least two contiguous clients, the one in the actual position and the one in position -1, so it calculates the costo of going since the destiny of the first one until having served the second
					//ES: si no esta en la primera posicion de la lista, tendra al menos dos clientes contiguos, el que esta en la posicion actual y en posicion -1, por lo que calcula el gasto de ir desde el destino del primero hasta haber servido al segundo
					if(posicion != 0){
						
							clientes aux5 <- actual.servicio[posicion - 1];
							clientes aux6 <- actual.servicio[posicion];
							
						if(posicion != indice + 1){
							
							gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: aux6.origen, source: aux5.destino);
										
										if(gasto_aux = nil){
							
											write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
											
										}
										
										else{
										
											if(length(gasto_aux.edges) > 0){
												
												loop j over: gasto_aux.edges{
													battery_loss <- battery_loss + float(general_speed_map [j]);
												}
												
											}
										
										}
										
							gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: aux6.destino, source: aux6.origen);
							ultima <- aux6.destino;			
										if(gasto_aux = nil){
							
											write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
											
										}
										
										else{
										
											if(length(gasto_aux.edges) > 0){
												
												loop j over: gasto_aux.edges{
													battery_loss <- battery_loss + float(general_speed_map [j]);
												}
												
											}
										
										}
								}
							
							
							//EN: if the position is equal to indice + 1 (inserted index + 1), it will have previously add the cost of going from the inserted destiny to the next origin, so this cost is not added again
							//ES: si la posicion es igual a indice + 1 (el indice del insertado + 1), ya habra sumado previamente el coste de ir del destino del insertado al siguiente origen, por lo que no se suma de nuevo
							else{
								gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: aux6.destino, source: aux6.origen);
								ultima <- aux6.destino;		
										if(gasto_aux = nil){
							
											write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
											
										}
										
										else{
										
											if(length(gasto_aux.edges) > 0){
												
												loop j over: gasto_aux.edges{
													battery_loss <- battery_loss + float(general_speed_map [j]);
												}
												
											}
										
										}
							}
								
					}
					
					
					//EN: if it is in the position 0 of the list, it will not have a previous client so the cost added is just the one associated to going to the client's origin and then to its destiny
					//ES: si esta en la posicion 0 de la lista, no habra un cliente previo por lo que el coste sumado sera el asociado a ir al origen del cliente y de ahi al destino
					else{
						clientes aux7 <- actual.servicio[posicion];
						
						gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: aux7.origen, source: source_intersection2);
									
									if(gasto_aux = nil){
						
										write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
										
									}
									
									else{
									
										if(length(gasto_aux.edges) > 0){
											
											loop j over: gasto_aux.edges{
												battery_loss <- battery_loss + float(general_speed_map [j]);
											}
											
										}
									
									}
									
						gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: aux7.destino, source: aux7.origen);
						ultima <- aux7.destino;			
									if(gasto_aux = nil){
						
										write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
										
									}
									
									else{
									
										if(length(gasto_aux.edges) > 0){
											
											loop j over: gasto_aux.edges{
												battery_loss <- battery_loss + float(general_speed_map [j]);
											}
											
										}
									
									}
					}
				}
			
			}
			
			
			//EN:if the list is empty, it only adds the cost of going to the inserted client's origin and then to its destiny
			//ES: si la lista esta vacia, solo suma el coste de ir al origen del cliente insertado y de ahi al destino
			else{
				gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: origen, source: source_intersection2);
									
									if(gasto_aux = nil){
						
										write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
										
									}
									
									else{
									
										if(length(gasto_aux.edges) > 0){
											
											loop j over: gasto_aux.edges{
												battery_loss <- battery_loss + float(general_speed_map [j]);
											}
											
										}
									
									}
									
				gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: destino, source: origen);
				ultima <- destino;					
									if(gasto_aux = nil){
						
										write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
										
									}
									
									else{
									
										if(length(gasto_aux.edges) > 0){
											
											loop j over: gasto_aux.edges{
												battery_loss <- battery_loss + float(general_speed_map [j]);
											}
											
										}
									
									}
			}
			
		}
		

		float min_distance <- 999999999999.9;
		float battery_loss_aux <- 0.0;
		
		
		//EN: the final step is to check which charger is the nearest and add the cost of going from the last position of the taxi (after serving the last client) to the charger
		//ES: el ultimo paso es calcular que estacion de carga es la mas cercana y sumar el coste de ir desde la ultima posicion del taxi (tras dejar al ultimo cliente) hasta la estacion de carga
		loop charge over: pos_chargers{
			
			gasto_aux <- aux_vehicle[0].compute_path(graph: road_network, target: charge, source: ultima);
				if(gasto_aux = nil){
	
					write("EL TAXI ESTA EN EL NODO ORIGEN AL APARECER EL CLIENTE");
					
				}
				
				else{
				
					if(length(gasto_aux.edges) > 0){
						
						loop j over: gasto_aux.edges{
							battery_loss_aux <- battery_loss_aux + float(general_speed_map [j]);
						}
						
					}
					
					if(battery_loss_aux < min_distance){
						min_distance <- battery_loss_aux;
						battery_loss_aux <- 0.0;
					}
				
				}
		}
		

		//EN: finally, it calculates the battery remaining after all this waste and, if it is above a threshold, the client will be inserted, while the client is rejected if it is below that threshold
		//ES: finalmente calcula la bateria restante tras este gasto y, si esta por encima del umbral, el cliente es insertado, mientras que es rechazado si esta por debajo del umbral
		battery_aux <- battery_aux - ((mass * 5.56 * 1 + 0.5 * air_density * air_resistance * projected_area *5.56^3 + rolling_resistance * mass * gravity * 5.56) * (battery_loss + min_distance));
		
		if(battery_aux < 0.15 * 20000000.0){
			energia_insuficiente <- true;
		}
		
		
	}

	
	//EN: reflex used to manage the cost of the time waited by each client based on a counter. This cost will be used as an extra when calculating where to insert the client
	//ES: reflex usado para gestionar el coste del tiempo de espera de cada cliente en base a un contador. ESte coste se usara como un extra al calcular donde insertar al cliente
	reflex increase_wait_time when: recogido = false{
		
		contador_espera <- contador_espera + 1;
		tiempo_espera <- contador_espera /20;
		time_wait[id] <- contador_espera;
		
	}	
	
	
}


//EN: experiment that defines the execution environment
//ES: experimento que define el entorno de ejecucion
experiment experiment_city type: gui {
	parameter "if true, 3D display, if false 2D display:" var: display3D category: "GIS";
	
	action _init_{
		
		//EN: parameters of the simulation, change as needed
		//ES: parametros de la simulacion, cambiar segun sea necesario
		create simulation with:[
			shape_file_roads::file("../includes/RoadsAranjuez.shp"), 
			shape_file_nodes::file("../includes/NodesAranjuez.shp"),
			nb_people::200,
			nb_taxis::5
		];
	}
	output {
		display Main type: opengl synchronized: true background: #gray{
			
			species road ;
			species intersection ;
			species people ;
			species taxis ;
			
		}
		
		
		//EN: the different charts to be displayed. Add more or change them if necessary
		//ES: los diferentes graficos a mostrar. Anadir mas o cambiar si es necesario
		display chart{
			chart "Clientes servidos por cada taxi" y_tick_unit: 1 type: histogram{
				datalist chart_names value: clients_per_taxi color: chart_color;
				
			}
		}
		
		display chart2{
			chart "Ciclos sin bateria de cada taxi" y_tick_unit: 1 type: histogram{
				datalist chart_names value: cycles_no_battery color: chart_color;
				
			}
		}
		
		display chart3{
			chart "Clientes aceptados y rechazados" type: pie{
				data "clientes aceptados" value: num_accepted color: #green;
				data "clientes rechazados" value: num_rejected color: #red;
				
			}
		}
		
		display chart4 refresh: every(1#cycles){
			chart "Tiempo de espera clientes"  type: series y_label: "Tiempo de espera en segundos" style: spline {
				datalist chart_client_names value: time_wait;
				
			}
		}
	}

}


